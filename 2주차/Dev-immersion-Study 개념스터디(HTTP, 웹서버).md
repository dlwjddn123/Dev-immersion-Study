# WEB

+ ## 목차
<br>

## 1. HTTP
## 2. apache, nginx와 Node.js의 차이
## 3. NoSQL과 RDBMS의 종류, 장단점 비교
<br>

---------------------------------------

## 1. HTTP

+ ### HTTP와 HTTPS에 대한 간단한 정의

HTTP(Hyper Text Transfer Protocol) 는 **인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.** <br>
프로토콜이란 데이터를 주고 받기 위한 통신 규칙이라고 보면 되겠다.<br>

그러면 HTTPS는 뭘까? HTTPS는 **Hypertext Transfer Protocol Over Secure Socket Layer** 약자이다.<br>
단어를 보면 알 수 있듯이 HTTP 프로토콜에서 보안 기능(SSL)이 추가된 프로토콜이라고 보면 된다.<br>

+ ### HTTP의 동작 방식 <br>

클라이언트(크롬, 사파리 등의 웹 브라우저, 모바일 등)가 브라우저를 통해서 어떠한 서비스를 **URI** 를 통해서<br>
서버에 요청(request)하면 서버에서는 해당 요청에 대한 결과를 응답(response)하는 형태로 동작한다.<br>
**URI는 Uniform Resource Identifier의 약자로 통합 자원 식별자라는 뜻을 가지고 있고** <br>
**쉽게 말하면 인터넷에 있는 자원을 나타내는 유일한 주소이다**<br>

+ ### HTTP의 요청 메소드
<br>

#### GET 방식
<pre>
<code>
  단어에서 유추 가능하듯이 특정 리소스(자원)을 받기 위한 요청이다. 따라서 리소스를 생성하거나 수정 및 삭제<br>
  등에 사용해서는 안된다.<br>
</code>
</pre>
<br>

#### POST 방식
<pre>
<code>
  주로 리소스를 생성하는데 사용한다. 쉽게 생각하면 우리가 게시판에 글을 작성할 때 사용된다고 볼 수 있겠다.
</code>
</pre>
<br>

#### PUT 방식
<pre>
<code>
  변경 가능한 리소스를 업데이트 하는데 사용한다. 작성한 글을 수정할 때 사용된다고 보면 이해하기 쉽다.
</code>
</pre>
<br>

#### DELETE 방식
<pre>
<code>
  단어에서 유추 가능하듯이 특정 리소스를 제거하는데 사용한다. 글 삭제에 사용.
</code>
</pre>
<br>

#### 이 외에도 HEAD, OPTIONS등이 있다
<br>
<br>


+ ### HTTP/1.1 과 HTTP/2 차이
<br>

<img src="https://miro.medium.com/max/1328/1*rf2AnDQyHfGO_ThYfb-hWA.png">

그림처럼 HTTP1.1은 기본적으로 연결당 하나의 요청과 응답을 처리하기 때문에 동시전송, 다수의 리소스를 <br>
처리하기에 속도와 성능 이슈를 가지고 있다.<br>
**이런 이슈를 해소시켜주는 것이 HTTP2이다.**<br>
HTTP2는**Multiplexed Streams, Stream Prioritization, Server Push, Header Compreestion** 을 사용하여<br>
성능 뿐만 아니라 속도 또한 눈에 띄게 향상 시켰다.<br>
<br>

**Multiplexed Streams : 하나의 연결에서 여러개의 메세지를 동시에 주고 받을 수 있음** <br>
**Stream Prioritization : 요청 리소스간 의존관계를 설정할 수 있음** <br>
**Server Push : HTML문서상에 필요한 리소스를 클라이언트의 요청 없이 보내줄 수 있음** <br>
**Header Compreestion : Header 정보를 HPACK압축방식을 이용하여 전송**<br>


<br>
<br>
<br>


+ ### 서버와 클라이언트
<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/1200px-Client-server-model.svg.png" width=80% height=80% >

클라이언트란? **네트워크가 연결되어있는 서버로부터 정보를 제공받는 컴퓨터를 의미한다.** <br>
예를 들면, 우리가 게임 클라이언트로 접속한다는 것은 게임 서버로부터 정보는 제공받는다는 것이다. <br>
그렇다면 서버란? **클라이언트에게 네트워크를 통해 정보를 제공하는 컴퓨터를 의미한다.** <br>
ex) 우리가 Node.js로 서버를 구축하고 서비스를 배포하면 다른 사람들이 우리 서버를 통해 웹을 사용할 수 있는 것이다. <br>
**컴퓨터라고만 말했지만 컴퓨터프로그램, 장치가 될 수도 있다.**
<br>
<br>
<br>
<br>
<br>

+ ### 상태코드
<br>
<img src="https://t4.daumcdn.net/thumb/R720x0/?fname=http://t1.daumcdn.net/brunch/service/user/1ffs/image/xxIKsvvQTLvhC0FJTrZIPuFas3o.jpg" width=65% height=65% >

상태코드는 **3자리 숫자**로 구성되고 **첫번째(백의 자리)자리는 1부터 5까지 있다**.<br>
**첫번째 자리 코드가 4,5인 경우는 정상적으로 작동하지 않았을 때 뜨는 코드로 사이트를 관리하는 괸리자라면 <br>
즉시 알아야할 정보이다.** <br>

+ 1xx(정보): 요청을 받았으며 프로세스를 계속 진행 <br>
+ 2xx(성공): 요청을 성공적으로 받았으며 서버에서 정상적으로 처리됌 <br>
+ 3xx(리다이렉션): 요청 완료를 위해 추가 작업 조치가 필요 <br>
+ 4xx(클라이언트): 요청의 문법이 잘못되었거나 요청을 처리할 수 없음 <br>
+ 5xx(서버오류): 서버가 명백하게 유효한 요청에 대해 충족을 실패 <br>

**이렇게 크게보면 5가지 종류가 있고 그 안에서 각각의 상태마다 더 자세하게 분류된다**
<br>
<br>
<br>
<br>

+ ### 쿠키와 세션
<br>
<img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F241EE049582DA37607" width=75% height=75% >

**쿠키와 세션을 사용하는 이유** <br>

HTTP 프로토콜은 connectionless, stateless이라는 두 가지 특징이자 약점이 있다. <br>

#### connectionless
<pre>
<code>
  클라이언트가 요청을 한 후 응답을 받으면 그 연결을 유지하지 않고 끊어버리는 특징이다.<br>
  HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라이언트 요청에 맞는 response를 보내고<br>
  연결을 끊음.
</pre>
</code>
<br>

#### stateless
<pre>
<code>
  통신이 끝나면 상태를 유지하지 않는 특징이다.<br>
  연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이다.<br>
</pre>
</code>
<br>

**이런 두 특징 때문에 쿠키와 세션을 사용하여 이를 보완한다.**<br>

**예를 들어, 쿠키와 세션을 사용하지 않으면 우리는 페이지를 이동할 때마다 로그인을 계속해야한다.**<br>
생각만 해도 귀찮다.. 보통 현재 웹사이트들은 쿠키와 세션을 사용하기 때문에 우리는 그런 불편함을 겪지 않는 것이다.<br>
쿠키와 세션을 만든 사람들에게 감사하며 어떠한 방식으로 사용자에 대한 인증을 유지하는지 알아보자.<br>
<br>

#### 쿠키란?
+ 쿠키는 클라이언트(브라우저)로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다.
+ 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되도 인증이 유지된다는 특징이 있다<br>
+ 쿠키는 클라이언트의 상태 정보를 로컬에 저장한 후 이를 참조한다.
+ 클라이언트에 최대 300개의 쿠키를 저장할 수 있고, 하나의 도메인당 20개의 값만 가질 수 있다.(하나의 쿠키값은 최대4kb)<br>
+ Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.<br>
+ 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.<br>
<br>

#### 쿠키의 구성 요소 <br>

+ 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
+ 값 : 쿠키의 이름과 관련된 값
+ 유효시간 : 쿠키의 유지시간
+ 도메인 : 쿠키를 전송할 도메인
+ 경로 : 쿠키를 전송할 요청 경로
<br>

#### 쿠키의 동작 방식
1. 클라이언트가 페이지를 요청(request)
2. 서버에서 쿠키를 생성
3. HTTP헤더에 쿠키를 포함시켜 응답(response)
4. 브라우저가 종료되어도 쿠키 만료 기간이 남아있다면 클라이언트에서 보관함
5. 같은 요청을 할 경우 HTTP헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 다시 HTTP헤더에 포함시켜 응답 <br>

#### 쿠키 사용 예시
+ 사이트에서 로그인 시, "아이디와 비밀번호를 저장하겠습니까?" 
+ 장바구니, 찜, 관심 등의 기능
+ 자동로그인, "오늘 더 이상 이 창을 보지 않음"
<br>
<br>

#### 세션이란? <br>

- 세션은 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리한다.
- 서버에서 클라이언트를 구분하기 위해 세션ID를 부여하여 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때 까지 인증상태를 유지한다.
- 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되게 않게 설정 가능(EX-> 장시간 응답 없을시 로그아웃)
- 사용자에 대한 정보를 서버에 두기 때문에 당연히 쿠키보다 보안에 좋지만, 사용자가 많아지면 많아질수록 서버 메모리에 과부하를 주게 된다.
- 즉, 동접자 수가 많은 웹 사이트인 경우에 성능 저하의 요인이 된다.
- 클라이언트가 request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데 이것이 세션ID이다.
<br>

#### 세션의 동작 방식

1. 클라이언트가 서버에 접속 시 세션ID를 발급 받는다.
2. 클라이언트가 세션ID에 대해 쿠키를 사용해서 저장하고 가지고 있는다.
3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션ID를 서버에 전달해서 사용한다.
4. 서버는 세션ID를 전달받아 별다른 인증작업없이 세션ID로 세션에 있는 클라이언트 정보를 가져온다.
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답한다.
<br>

#### 세션의 특징 <br>

+ 각 클라이언트에게 고유ID를 부여
+ 세션ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
+ 쿠키보다 보안성이 높음
+ 사용자가 많아질수록 서버 메모리를 많이 차지함
<br>

**로그인같이 보안상 중요한 작업을 수행할 때 사용**
<br>

#### 쿠키와 세션의 차이점 <br>

**쿠키와 세션의 동작방식은 비슷하지만 차이점은 저장되는 위치, 라이프 사이클에 있다.**  <br>
**쿠키는 브라우저에 저장되지만 세션은 서버에 저장된다. 때문에 보안 측면에서는 세션이 더 우수하지만**  <br>
**요청속도 면에서 쿠키는 세션보다 빠른데 그 이유는 세션처럼 서버의 처리를 거치지 않기 때문이다.**  <br>
<br>

요즘 추세는 이런 문제들은 보완한 토큰 기반의 인증방식을 사용한다고 한다.**(트렌드를 따라가자)** <br>
<br>

----------------------------------
## 2. apache, nginx와 Node.js의 차이
<br>
<img src="https://miro.medium.com/max/500/1*Kf9t7AlcpVFLufrAbcEX0w.png">

**먼저 웹 서버와 WAS(Web Application Server)에 대한 개념부터 이해해보자**
<br>

#### 웹 서버
+ 클라이언트의 요청에 의해 정적 파일을 제공하는 서버로 Apache, Nginx가 이에 해당하며, 정적파일만 제공할 수 있다.<br>

#### WAS
+ 웹 서버와 웹 컨테이너를 포함한 개념. 웹 서버에서는 정적 파일만 제공하므로, 동적으로 DB와 연결하여 여러 데이터를<br>
활용해 php, jsp, asp로 표현된 페이지를 해석할 수 있어야 하는데 이 역할을 웹 컨테이너가 제공한다.

#### 웹 서버와 WAS를 분리한 이유
<br>

+ 이 둘을 분리하면 웹 서버를 한번 거치기 때문에 보안상의 이점이 존재함. 또한 웹 서버에서 어떤 오류가 발견됬을 때 <br>
이를 업데이트 해줘야 하는데 이를 끊김없이 서비스를 제공할 수 있다.<br>

#### Node.js와 Apache, nginx의 차이 <br>

+ Node.js는 정적 파일과 함께 WAS기능(=언어 해석)을 모두 제공한다. Express(프레임워크)를 통해 정적 파일을 제공하고,<br>
나머지가 언어해석, DB연동 등을 담당한다<br>

+ 이에 반해 Apache, nginx는 정적 파일만 제공할 수 있고 동적인 것들은 WAS를 통해 제공할 수 있다는 점에서 다르다.<br>

<br>

------------------------------------------------------
## 3. RDBMS와 NoSQL의 종류, 장단점 비교 <br>
<img src="https://blog.kakaocdn.net/dn/bpf9l6/btqV0DvZMge/SCtUJH8ffnd4JIzJSVuGDK/img.png">

### RDBMS란? <br>

+ 우선 SQL(Structured Query Language)은 데이터베이스에서 사용하는 쿼리 언어이고.<br>
SQL을 사용하여 RDBMS에서 데이터를 검색, 저장, 수정, 삭제 등이 가능하다.
+ RDB(Relational Database)란 관계형 데이터 모델에 기초를 둔 데이터베이스다.
관계형 데이터 모델이란 데이터를 구성하는데 필요한 방법 중 하나로 모든 데이터를 2차원 테이블 형태로 표현해준다.
+ 따라서 RDBMS(Relational Database Management System)란 관계형 데이터베이스를 생성하고 수정, 삭제 관리할 수 있는 소프트웨어라고 정의할 수 있다.
<br>

### NoSQL란? <br>

+ NOSQL(Not Only SQL)은 관계형 데이터베이스와 반대되는 방식을 사용하여 데이터간의 관계를 정의하지 않는다.
+ RDBMS에서는 스키마에 맞추어 데이터를 관리하여야 하지만 NOSQL은 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있다
+ NOSQL에서 테이블과 같은 개념으로 컬렉션이라는 형태로 데이터를 관리한다.
<br>

### RDBMS와 NoSQL의 장단점
#### RDBMS
#### 장점
+ RDBMS는 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장한다. 
+ 또한 관계는 각 데이터를 중복없이 한 번만 저장할 수 있다.

#### 단점
+ 테이블간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있다.
+ 성능 향상을 위해서는 서버의 성능을 향상 시켜야하는 Scale-up만을 지원한다. 이로 인해 비용이 기하급수적으로 늘어날 수 있다.
+ 스키마로 인해 데이터가 유연하지 못하고, 나중에 스키마가 변경 될 경우 번거롭고 어렵다.
<br>

#### NoSQL
#### 장점
+ NoSQL에서는 스키마가 없기 때문에 유연하고 자유로운 데이터 구조를 가질 수 있다.<br>
언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
+ 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만이 아닌 Scale-out 또한 가능하다.

#### 단점
+ 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행을 해야 한다.
+ 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있다.










