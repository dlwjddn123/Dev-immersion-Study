# 목차

----------------------------

## 1. ORM의 One-to-One, Many-to-One, One-to-Many, Many-to-Many 각각 언제 사용할까?
## 2. ORM의 N+1 문제란?
## 3. 객체지향은 무엇이며 어떤 장점이 있길래 사용하는걸까?
## 4. 리팩터링은 무엇이며 왜 그렇게 중요할까?
## 5. 테스트 코드는 왜 중요하며, TDD란 무엇인가?

--------------------------------

### 1. ORM의 One-to-One, Many-to-One, One-to-Many, Many-to-Many 각각 언제 사용할까?

<img src="https://t1.daumcdn.net/cfile/tistory/99FA24405E1EC3C62A"> 
<br>

+ ### One to One(1:1)
#### 두 엔티티가 단 하나의 관계를 가지는 것

위의 사진을 예로 설명하자면, <br>
1:1 과외수업이라고 했을 때, 그리고 선생님이 단 한 명의 학생밖에 가르치지 않을때, <br>
학생과 선생님은 서로 하나의 관계를 가진다. 

+ ### One to Many(1:N)
#### 두 엔티티중 하나의 엔티티에서만 여러 관계를 가지는 것

위의 예시에서 계속해서 설명하자면, <br>
1:1 과외 수업이지만, 선생님이 여러 학생을 가르칠 때, <br>
선생님(1)과 학생(M)은 1:M관계, 즉 선생님 측에서 여러 관계를 맺을 수 있다.

+ ### Many to Many(1:N)
#### 두 엔티티가 서로 여러 관계를 가지는 것

**(위에 예시에서는 학생이 한 가지 과목만 과외수업을 받는다는 전제하의 관계)** <br>
이번 예시에서는 학생이 여러 과목의 과외수업을 받을 수 있다는 가정하에 설명해보자면, <br>
학생은 여러 과외 선생님과의 관계를 가질 수 있고, 선생님 또한 여러 학생과 관계를 가질 수 있다. <br>

--------------------------------------

### 2. ORM의 N+1 문제란?

+ #### 쿼리 1번으로 N건의 데이터를 가져왔지만, 원하는 데이터를 얻기위해 N번을 추가로 수행하는 문제

예시로 

``` MySQL
# 학생테이블
CREATE TABLE student (
  sid INT NOT NULL AUTO_INCREMENT,
  name VARCHAR(20) NOT NULL,
  cid VARCHAR(20) NOT NULL,
  PRIMARY KEY(sid),
  FOREIGN KEY(cid) REFERENCES course(cid)
  );
# 수업테이블
CREATE TABLE course (
  cid VARCHAR(20) NOT NULL,
  name VARCHAR(20) NOT NULL,
  PRIMARY KEY(cid),
  );
# 적당한 값을 넣고
 insert into course(cid, name) values('c-1', '코스1'),('c-2','코스2'),('c-3', '코스3'),('c-4','코스4');
 insert into student(name, cid) values('이정우1', 'c-1'),('이정우2','c-2'),
('이정우3','c-3'),('이정우4','c-4');
# 학생 테이블 출력
+-----+---------+-----+
| sid | name    | cid |
+-----+---------+-----+
|   1 | 이정우1 | c-1 |
|   2 | 이정우2 | c-2 |
|   3 | 이정우3 | c-3 |
|   4 | 이정우4 | c-4 |
+-----+---------+-----+
# 수업 테이블 출력
+-----+-------+
| cid | name  |
+-----+-------+
| c-1 | 코스1 |
| c-2 | 코스2 |
| c-3 | 코스3 |
| c-4 | 코스4 |
+-----+-------+
```

여기서 수업 테이블을 이용해 수업을 듣는 **모든** 학생의 정보를 알아내려고 할 때, <br>
``` javascript
const courses = await courses.query(`SELECT * FROM course`)

for (let course of courses) {
  const student = await student.query(`
    SELECT * 
    FROM student
    WHERE cid = :course.cid
  `)
  .setParam('course.cid', course.cid)
}
```
**이렇게 코드를 짜면 N+1문제가 발생한다.** <br>
실제로 어떻게 쿼리문이 들어가는지 보면 <br>

``` MySQL 
SELECT * FROM course; # 1번쿼리

SELECT * FROM student WHERE cid = "c-1"; -- 이정우1; # 2번쿼리
SELECT * FROM student WHERE cid = "c-2"; -- 이정우2; # 3번쿼리
SELECT * FROM student WHERE cid = "c-3"; -- 이정우3; # 4번쿼리
SELECT * FROM student WHERE cid = "c-4"; -- 이정우4; # 5번쿼리
```
**이런식으로 들어가게 된다. 1번쿼리를 날리고 course의 데이터만큼(N)을 더해서 쿼리를 날리는 것이 N+1문제이다.(lazy 전략)** <br>

하지만 이를
``` javascript
const courses = await courses.query(`
  SELECT * 
  FROM course c
  JOIN student s
  ON c.cid = s.cid
`)

for (let course of courses) {
  const student = course.student
}
```
이런식으로 코드를 짜게 된다면 실제 쿼리문은 <br>
``` MySQL
  SELECT * FROM course c JOIN student s ON c.cid = s.cid;
  ```
 
이렇게나 간단해진다. **이런 방식으로 동작하는 전략이 eager 이고 relation 설정 시 {eager : true}로 설정 할 수 있다.** <br>

**하지만 eager는 불필요한 데이터까지 전부 가져올 수 있으므로 잘 판단해서 사용해야 한다.** <br>


---------------------------------------------

### 3. 객체지향은 무엇이며 어떤 장점이 있길래 사용하는걸까?
<br>

+ ### 객체 지향 프로그래밍이란?

<br>

<pre>
<code>
우리가 실생활에서 쓰는 모든 것을 객체라 하며, <br>
객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 각각의 객체들의 역할이 무엇인지를 정의하여 <br>
객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말한다. 객체는 클래스라는 틀에서 생겨난 실체(instance)이다.<br>
따라서 객체 지향 프로그램은 객체와 객체 간의 연결로 되어 있으며 각각의 객체 안에 자료구조와 알고리즘이 들어있는 것이다.<br>
</pre>
</code>

### 객체 지향 프로그래밍의 특징

<br>

#### 1. 추상화
+ 객체들의 공통적인 특징(기능, 속성)을 도출하는 것
#### 2. 캡슐화
+ 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉할 수 있다.
#### 3. 상속성
+ 하나의 클래스가 가진 특징(함수, 데이터)을 다른 클래스가 그대로 물려받는 것
#### 4. 다형성
+ 약간 다른 방법으로 동작하는 함수를 동일한 이름으로 호출하는 것
#### 5. 동적바인딩
+ 가상 함수를 호출하는 코드를 컴파일할 때, 바인딩을 실행시간에 결정하는 것.

<br>

### 객체 지향 프로그래밍의 장점

<br>

#### 소프트웨어의 생산성 향상
객체지향 프로그래밍은 다형성, 객체, 캡슐화 등 소프트웨어의 재사용을 지향한다.<br>
이미 만들어진 클래스를 상속받거나 객체를 가져다 재사용하거나, 부분 수정을 통해, 소프트웨어를 작성하는 부담을 대폭 줄일 수 있다.<br>
+ 신뢰성 있는 소프트웨어를 손쉽게 작성할 수 있다. (개발자가 만든 데이터를 사용하기 때문에 신뢰할 수 있다.)
+ 코드를 재사용하기 쉬우며 업그레이드, 디버깅이 쉬워진다.

#### 실세계에 대한 쉬운 모델링

컴퓨터가 산업 전반에 다양하게 활용되는 요즘 시대에는 응용 소프트웨어를 하나의 절차로 모델링하기 어렵다.<br>
산업 전반에서 요구되는 응용 소프트웨어 특성상, 절차나 과정보다 관련된 많은 물체(객체)들의 상호 작용으로 묘사하는 것이 더 쉽고 적합하다.<br>

#### 보안성 향상

객체 지향적 프로그래밍의 캡슐화 특징으로 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉할 수 있다.<br> 

---------------------------------------------------

### 4. 리팩토링은 무엇이며, 왜 그렇게 중요할까?

<br>

#### 리팩토링이란?
<br>

이미 작성한 소스코드에서 구현된 일련의 행위들을 변경없이, 코드의 가독성과 유지보수성을 높이기 위해 내부 구조를 변경하는 것이다. <br>
다시 말해서 기능을 유지하면서 더 읽기 좋고 관리하기 편하게 소스코드를 재작성 하는 것이다.

#### 중요한 이유는?

+ 소프트웨어 설계에서 질적 향상을 위해서. 코드 중복제거, 수정 용이성 향상
+ 소프트웨어 이해도를 향하하고 가독성 향상을 위해서.
+ 버그를 찾기 쉽게 해준다.
+ 프로그램 개발 속도가 향상된다.(좋은 설계 기반에서 한다면).

**즉, 다시말하면 가독성, 유지보수성, 협업을 위해 매우 중요하다고 할 수 있다.** <br>


---------------------------------------------------------------

### 5. 테스트 코드가 왜 중요하며, TDD란 무엇인가?

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTquYwsSmqoGdno6LVW06qRwHgJysZvJl_nI6Ju3-BrCSa0LxrYGq8vFKTo1NbdUrV3tr4&usqp=CAU" width=450 height=450>

#### 먼저 TDD란?
Test Driven Development의 약자로 해석하면 테스트 주도 개발이다. <br>
말 그대로 테스트가 개발을 이끌어 나간다는 뜻으로, 테스트 케이스를 먼저 작성하고 프로그래밍 하는 방식을 말한다. <br>

#### TDD의 장단점
+ 개발 시간이 더 길어진다.
+ 결함이 줄어든다.
+ 깨끗한 코드로 유지 보수 비용이 낮아진다.

#### 테스트 코드가 중요한 이유

+ 개발 단계 초기의 문제 발견을 도와줌
+ 개발자가 나중에 코드를 리팩토링 하거나, 기존 기능을 업그레이드 하는 과정에 올바르게 작동하는 지 확인할 수 있음
+ 따라서, 기능의 불확실성을 감소시킴
+ 시스템에 대한 실제 문서를 제공. 즉 단위 테스트 자체가 문서로 사용할 수 있음.


